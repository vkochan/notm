#!/usr/bin/env bash

# Requirements: Bash, Coreutils

PREFIX=$(dirname $(dirname "$0"))

. ${PREFIX}/lib/notm/sentaku -n

_SENTAKU_SEPARATOR=$'\n'
_SENTAKU_EDITOR=""

TM_RED=31
TM_GREEN=32
TM_YELLOW=33
TM_BLUE=34
TM_WHITE=97

TM_ROOT="$(readlink -f ${PWD})"
TM_BASENAME="$(basename $TM_ROOT)"

TM_OPENER=${EDITOR:-vim}

_tm_states=("TODO" "IN-PROGRESS" "DONE")
_tm_selected=()

relpath() {
  realpath --relative-to=$1 $2
}

locpath() {
  local rel_root="$(realpath --relative-to=$(dirname ${1}) ${TM_ROOT})"
  local rel_path="$(realpath --relative-to=${TM_ROOT} ${1})"

  echo "${rel_root}/${rel_path}"
}

_tm_cleanup_links() {
  find -L ${TM_ROOT} -type l -delete
  find ${TM_ROOT}/TODO -empty -type d -delete 2> /dev/null
  find ${TM_ROOT}/DONE -empty -type d -delete 2> /dev/null
  find ${TM_ROOT}/IN-PROGRESS -empty -type d -delete 2> /dev/null
}

# $1 - task relative path
# $N - states
_tm_unlink_state() {
  local rel_path=$1

  shift 1

  while [[ $# -gt 0 ]] 
  do
    unlink ${TM_ROOT}/${1}/${rel_path} 2> /dev/null
    shift 1
  done
}

_tm_state_color() {
  local color=$TM_WHITE

  case "$1" in
    "DONE")
           color=$TM_BLUE
           ;;
    "TODO")
           color=$TM_GREEN
           ;;
    "IN-PROGRESS")
           color=$TM_YELLOW
           ;;
  esac

  echo $color
}

_tm_change_state() {
  local new_state="$1"
  local rel_dir=""
  local new_dir=""
  local task=""

  shift 1

  while [[ $# -gt 0 ]] 
  do
    if [ -f "$1" ]; then
      rel_dir=$(relpath "${TM_ROOT}/TASKS" $(dirname $1))
      new_dir="${TM_ROOT}/${new_state}/${rel_dir}"
      task=$(basename $1)

      case $new_state in
                "TODO")
                     _tm_unlink_state "${rel_dir}/${task}" "IN-PROGRESS" "DONE"
                     ;;
        "IN-PROGRESS")
                     _tm_unlink_state "${rel_dir}/${task}" "TODO" "DONE"
                     ;;
               "DONE")
                     _tm_unlink_state "${rel_dir}/${task}" "TODO" "IN-PROGRESS"
                     ;;
      esac

      mkdir -p ${new_dir}

      ln -sf $(locpath ${TM_ROOT}/TASKS/${rel_dir}/${task}) ${new_dir}/${task}

      _tm_cleanup_links
    fi

    shift 1
  done

  _s_v_selected=()
  _tm_selected=()
}

_tm_init() {
    mkdir $PWD/TASKS

    _tm_cleanup_links
}

_tm_refresh() {
  _sf_get_values
  _sf_reset
}

_tm_echo_on() {
  tput cnorm >/dev/tty 2>/dev/null || tput vs >/dev/tty 2>/dev/null
  tput el > /dev/tty
  stty $_s_stty
  stty echo
}

_tm_echo_off() {
  _sf_hide
  _tm_refresh
}

_tm_ls() {
  if [ "${PWD}" == "${TM_ROOT}" ]; then
    echo "TASKS"
    echo "IN-PROGRESS"
    echo "TODO"
    echo "DONE"
  else
    ls -l $* | sort | awk 'NF>=9 { print $9 }'
  fi
}

_sf_get_values() { # {{{
  # Get variables
  local orig_ifs=$IFS
  IFS="$_s_s"
  _s_inputs=(".." $(_tm_ls))
  IFS=$orig_ifs
  _s_n=${#_s_inputs[@]}
} # }}}

array_contains() {
  local e match="$1"
  shift

  for e; do [[ "$e" == "$match" ]] && return 0; done

  return 1
}

_sf_printline() { # useage: _sf_printline is_selected n_line n_input {{{
  local entry=${_s_inputs[$3]}
  local path=$(readlink -f ${entry})
  local show=${entry}
  local prefix=""
  local state
  local color

  if [ "${PWD}" == "${TM_ROOT}" -a "${entry}" != "TASKS" -a "${entry}" != ".." ]; then
    show="#${show}"
  fi

  tput cup $2 0 >/dev/tty
  if [ $1 -eq 1 ];then
    printf "\e[7m" >/dev/tty
  fi

  if [ -d "${entry}" -a "${entry}" != ".." ]; then
    color=$(_tm_state_color "$entry")
    show="\e[$color;1m$show\e[0m [$(find $entry -type f -or -type l | wc -l)]"
  fi

  if ((_s_v_selected[$3] == 1)); then
    if [ "$entry" != ".." ]; then
      if ! array_contains "${path}" "${_tm_selected[@]}"; then
        _tm_selected+=(${path})
      fi 
      prefix=" +"
    fi
  else
    prefix="  "
  fi

  if [[ "$PWD" =~ "$TM_ROOT/TASKS" ]]; then
    if [ -f "${entry}" ]; then
      for state in "${_tm_states[@]}"; do
          [ ! -d "${TM_ROOT}/${state}" ] && continue

          if find "${TM_ROOT}/${state}" -type l | xargs readlink -f | grep -n -q -F "${path}"; then
            color=$(_tm_state_color "$state")
            show="$(printf "\e[$color;1m%-11s\e[0m | %s" ${state} ${show})"
          fi
      done
    fi
  fi

  printf "${prefix}${show}" > /dev/tty
  printf "\e[m" >/dev/tty
  tput cup $2 0 >/dev/tty
} # }}}

_sf_select() { # {{{
  local e=${_SENTAKU_EDITOR:-${EDITOR}}

  if [ -d "${_s_inputs[$_s_current_n]}" ];then
    cd "${_s_inputs[$_s_current_n]}"
    _tm_refresh
  elif [ -f "${_s_inputs[$_s_current_n]}" ]; then
    ${TM_OPENER} ${_s_inputs[$_s_current_n]} >/dev/tty </dev/tty
    _sf_clear
    _tm_refresh
  fi
} # }}}

_sf_set_header() { # {{{
  local cwd_header
  local rel_path=""

  if [ "$TM_ROOT" != "$PWD" ]; then
    rel_path=" $(relpath $TM_ROOT $PWD)"
  fi

  cwd_header="\\e[43;30m${TM_BASENAME}|${rel_path}\\e[0m"
  _s_header="$cwd_header"
} # }}}

_sf_p() {
  if [[ ! "$PWD" =~ "$TM_ROOT/TASKS" ]]; then
      return
  fi

  for e in "${_tm_selected[@]}"; do 
    cp -r "$e" $PWD
  done

  _s_v_selected=()
  _tm_selected=()

  _tm_refresh
}

_sf_v() {
  if [[ ! "$PWD" =~ "$TM_ROOT/TASKS" ]]; then
      return
  fi

  for e in "${_tm_selected[@]}"; do 
    mv "$e" $PWD
  done

  _s_v_selected=()
  _tm_selected=()

  _tm_refresh
}

_sf_x() {
  if (( ${#_tm_selected[@]} > 0 )); then
    echo "Delete selected items ? (y/n)"
  else 
    echo "Delete ${_s_inputs[$_s_current_n]}? (y/n)"
  fi
  _sf_read

  if [ "$_s_read" = "y" ];then
    if (( ${#_tm_selected[@]} > 0 )); then
      for e in "${_tm_selected[@]}"; do 
        rm -rf "$e"
      done
      _s_v_selected=()
      _tm_selected=()
    else
      rm -rf ${_s_inputs[$_s_current_n]}
    fi
  fi

  _tm_cleanup_links
  _tm_refresh
}

_sf_c_d() {
  if [[ ! "$PWD" =~ "$TM_ROOT/TASKS" ]]; then
      return
  fi

  if (( ${#_tm_selected[@]} > 0 )); then
    _tm_change_state "DONE" ${_tm_selected[@]}
  else
    _tm_change_state "DONE" "$(readlink -f ${_s_inputs[$_s_current_n]})"
  fi
}

_sf_c_p() {
  if [[ ! "$PWD" =~ "$TM_ROOT/TASKS" ]]; then
      return
  fi

  if (( ${#_tm_selected[@]} > 0 )); then
    _tm_change_state "IN-PROGRESS" ${_tm_selected[@]}
  else
    _tm_change_state "IN-PROGRESS" "$(readlink -f ${_s_inputs[$_s_current_n]})"
  fi
}

_sf_c_t() {
  if [[ ! "$PWD" =~ "$TM_ROOT/TASKS" ]]; then
      return
  fi

  if (( ${#_tm_selected[@]} > 0 )); then
    _tm_change_state "TODO" ${_tm_selected[@]}
  else
    _tm_change_state "TODO" "$(readlink -f ${_s_inputs[$_s_current_n]})"
  fi
}

_sf_t() {
  local rel_dir

  if [[ ! "$PWD" =~ "$TM_ROOT/TASKS" ]]; then
      return
  fi

  rel_dir=$(relpath "$TM_ROOT/TASKS" "$PWD")

   _tm_echo_on

   read -p "task name: " task
   touch "$task"

   mkdir -p ${TM_ROOT}/TODO/${rel_dir}
   ln -sf $(locpath $(readlink -f ${task})) ${TM_ROOT}/TODO/${rel_dir}/${task}

   _tm_echo_off
}

_sf_g() {
  if [[ ! "$PWD" =~ "$TM_ROOT/TASKS" ]]; then
      return
  fi

  if [ "$(relpath $TM_ROOT $PWD)" != "." ]; then
    _tm_echo_on

    read -p "group name: " group
    mkdir $group

    _tm_echo_off
  fi
}

_sf_r() {
   local oldfiles
   local newfiles
   local oldname
   local oldpath
   local rel_path
   local newpath

  if [[ ! "$PWD" =~ "$TM_ROOT/TASKS" ]]; then
      return
  fi

   oldname=${_s_inputs[$_s_current_n]}
   oldpath="$(readlink -f $oldname)"
   oldfiles=( $(find "${oldpath}" -type f) )

   _tm_echo_on

   read -e -i $oldname -p "new name: " newname

   newpath="$(readlink -f ${newname})"

   _tm_echo_off

   if ! mv $oldname $newname; then
       return
   fi

   newfiles=( $(find "${newpath}" -type f) )

   for path in "${oldfiles[@]}"; do
      for state in "${_tm_states[@]}"; do
          [ ! -d "${TM_ROOT}/${state}" ] && continue

          if find "${TM_ROOT}/${state}" -type l | xargs readlink -m | grep -n -q -F "${path}"; then
            _tm_change_state "${state}" ${newfiles[@]}
          fi
      done
   done

  _tm_cleanup_links
  _tm_refresh
}

_sf_h() { # {{{
  if [ "$(relpath $TM_ROOT $PWD)" != "." ]; then
    cd ..
    _tm_refresh
  fi
} # }}}

_sf_l() { # {{{
  if [ "${_s_inputs[$_s_current_n]}" != ".." ]; then
    _sf_select $@
  fi
} # }}}

while [[ $# -gt 0 ]]
do
  case $1 in
    "-d")
        cd $2
        TM_ROOT="$(readlink -f ${PWD})"
        TM_BASENAME="$(basename $TM_ROOT)"
        shift 1
        ;;
  esac
  shift 1
done

_tm_init

_sf_main "$@"
